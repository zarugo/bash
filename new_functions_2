###################################################################
#Script Name	: Funcions repo for update_jps.sh - not to be executed directly
#Description	: Provides functions needed to the main script
#Args        	: None
#Release      : 1.12.5.5
###################################################################
TYPE=""
HW=""
SCRIPTEXT=""

#usage help
function usage() {
    echo -e "You must provide at most 2 argument:\n -) the IP address of the device to upgrade or the local PATH for local update\n -) the port)\n"
    echo -e "\n   Usage:\n   $0 [IP|PATH] [PORT] \n"
}

#Get the application type and set global variables
#about folders and hardware
function get_loc_type () {
  	read -p "Set the target env to update (jhw/rpi/win)? " answer
	case ${answer:0:1} in
		j )
			echo jhw
			HW=jhw
			SCRIPTEXT=.sh
		;;
		r )
			echo rpi
			HW=rpi
			SCRIPTEXT=.sh
		;;
		w )
			echo win
			HW=win
			SCRIPTEXT=.bat
		;;
		* )
			echo Unsupported target!
			exit
		;;
	esac

  read -p "Device type is unknown...Set the target pp to update (AppAps/AppLe/AppLx/AppApl/AppOv/AppDr/AppLs/AppRdrWtr)? " TYPE
}

#Get the remote application type and set global variables
#about folders and hardware
function get_rem_type () {
  TYPE=$(curl -s -m 2 http://$JPS_DEVICE_IP:$JSPORT/jps/api/status) #try 1st the default port 65000 (or the port passed by argument)
  if [[ $? -eq 28 ]]; then
    JSPORT=65010   #TBD: what is the port??
    TYPE=$(curl -s -m 2 http://$JPS_DEVICE_IP:$JSPORT/jps/api/status) #try the 2nd standard port
    if [[ $? -eq 28 ]]; then
      echo -e "\nDevice type is unknown...make sure the JPSApplication is running on the device and the IP address is correct"
      exit 1
    fi
  fi
  HW=$(ssh -o "StrictHostKeyChecking no" root@$JPS_DEVICE_IP "hostname")

  if [[ $HW == "ebb-hw-jhw-2-0" ]]
    then
	HW=jhw
	SCRIPTEXT=.sh
  elif [[ $HW == "raspberrypi" ]]
    then
	HW=rpi
	SCRIPTEXT=.sh
  else
    echo -e "\nHardware type "$HW" is unknown"
    exit 1
  fi
 }

#Get the application type and set global variables
#about folders and hardware
function get_type () {

	if [[ -d "$JPS_PARENT_PATH" ]]; then
		get_loc_type
	else
		get_rem_type
	fi

	case $TYPE in
		*AppAps*)
		LOGIN=root
		TYPE=AppAps
		APPFLD=ApsApp
		WEBFLD=apsapp
		SCRIPT=ApsApp$SCRIPTEXT
		WORKDIR=$JPS_PARENT_PATH
		;;
		*AppLe*)
		LOGIN=root
		TYPE=AppLe
		APPFLD=LeApp
		WEBFLD=leapp
		SCRIPT=LeApp$SCRIPTEXT
		WORKDIR=$JPS_PARENT_PATH
		;;
		*AppLx*)
		LOGIN=root
		TYPE=AppLx
		APPFLD=AplApp
		WEBFLD=aplapp
		SCRIPT=LxApp$SCRIPTEXT
		WORKDIR=JPS_PARENT_PATH
		;;
		*AppApl*)
		LOGIN=root
		TYPE=AppApl
		APPFLD=AplApp
		WEBFLD=aplapp
		SCRIPT=AplApp$SCRIPTEXT
		WORKDIR=$JPS_PARENT_PATH
		;;
		*AppOv*)
		LOGIN=root
		TYPE=AppOv
		APPFLD=ApsApp
		WEBFLD=apsapp
		SCRIPT=OvApp$SCRIPTEXT
		WORKDIR=$JPS_PARENT_PATH
		;;
		*AppDr*)
		LOGIN=root
		TYPE=AppDr
		APPFLD=LeApp
		WEBFLD=leapp
		SCRIPT=DrApp$SCRIPTEXT
		WORKDIR=$JPS_PARENT_PATH
		;;
		*AppLs*)
		LOGIN=root
		TYPE=AppLs
		APPFLD=LeApp
		WEBFLD=leapp
		SCRIPT=LsApp$SCRIPTEXT
		WORKDIR=$JPS_PARENT_PATH
		;;
		*AppRdrWtr*)
		LOGIN=root
		TYPE=AppRdrWtr
		APPFLD=ApsApp
		WEBFLD=apsapp
		SCRIPT=RdrWtrApp$SCRIPTEXT
		WORKDIR=$JPS_PARENT_PATH
		;;
			 *)
		echo -e "\nDevice $TYPE type is unknown...make sure the JPSApplication is running on the device"
		exit 1
		;;
	esac

    echo -e "\nFound supported $TYPE type"
}
#get the JPS config files
function get_config() {
  cp ./JPSApps_$HW/JPSApplication/Resources/www/webcfgtool/${WEBFLD}/ConfigData.json ./ConfigData_NEW.json
  cp ./JPSApps_$HW/JPSApplication/Resources/www/webcfgtool/outsched/ConfigData.json ./ConfigData_SCHED_NEW.json
  cp -r JPSApps_$HW JPSApps
  find ./JPSApps/JPSApplication/ -name "*AppRun$SCRIPTEXT" ! -name "${SCRIPT}" -delete
  find ./JPSApps/JPSApplication/Resources -maxdepth 1 -type d -name "*App" ! -name "${APPFLD}" -exec rm -fr {} \; &>/dev/null
  find ./JPSApps/JPSApplication/Resources/www/webcfgtool -type d -name "*app" ! -name "${WEBFLD}" -exec rm -fr {} \; &>/dev/null
  rm ./JPSApps/JPSApplication/Resources/AdditionalData.json_* ./JPSApps/JPSApplication/Resources/www/webcfgtool/${WEBFLD}/ConfigData.json_* 2>/dev/null
  cp ./JPSApps/JPSApplication/${SCRIPT} ./JPSApps/JPSApplication/XXXAppRun$SCRIPTEXT

  if [[ -d $JPS_PARENT_PATH ]]; then
	cp $WORKDIR/JPSApps/JPSApplication/Resources/www/webcfgtool/outsched/OutSched/ConfigData.json ./ConfigData_SCHED_ORIG.json 1>/dev/null
	cp $WORKDIR/JPSApps/JPSApplication/Resources/www/webcfgtool/${WEBFLD}/${APPFLD}/ConfigData.json ./ConfigData_ORIG.json 1>/dev/null
  else
	scp -o "StrictHostKeyChecking no" -p $LOGIN@$JPS_DEVICE_IP:$WORKDIR/JPSApps/JPSApplication/Resources/www/webcfgtool/outsched/OutSched/ConfigData.json ./ConfigData_SCHED_ORIG.json 1>/dev/null
	scp -o "StrictHostKeyChecking no" -p $LOGIN@$JPS_DEVICE_IP:$WORKDIR/JPSApps/JPSApplication/Resources/www/webcfgtool/${WEBFLD}/${APPFLD}/ConfigData.json ./ConfigData_ORIG.json 1>/dev/null
  fi
}


function update_script() {
  #create a script to be executed remotely
  cat << EOF > _update.sh
  #!/bin/bash
  #set -x
  WORKDIR=$WORKDIR

  #double check we are in the correct directory
  if [ \$(pwd) != \$WORKDIR ]
  	then
  	cd \$WORKDIR
  fi
  #double check that we have the package
  if ! [ -f ./JPSApps.tar.gz ]
  	then
  	echo 'REMOTE: No JPSApps.tar.gz package found for update '
  	exit 1
  fi
  TOKEN=\${WORKDIR}/JPSApps/JPSApplication/Resources/${APPFLD}/AppDB.fdb
  TOKENDIR=\${WORKDIR}/JPSApps/JPSApplication/Resources/${APPFLD}
  if [[ -f \$WORKDIR/JPSApps/JPSApplication/Resources/Cash/cashDB.fdb ]]
    then
    APS=true
    CASH=\${WORKDIR}/JPSApps/JPSApplication/Resources/Cash/cashDB.fdb
    CASHDIR=\${WORKDIR}/JPSApps/JPSApplication/Resources/Cash
  fi
  JSDIR=\${WORKDIR}/JPSApps/JPSApplication/Resources/www/webcfgtool/${WEBFLD}

  function rollback() {
    rm -fr JPSApps 2>/dev/null 1>&2
    mv JPSApps_old JPSApps
    rm -rf _update.sh cashDB.fdb AppDB.fdb JPSApps.tar.gz ConfigData* 2>/dev/null 1>&2
  }

  #kill everything
  curl -d '{"mode":"SoftKill"}' -H "Content-Type: application/json" -X POST -s -m 5 http://127.0.0.1:$JSPORT/jps/api/command/reboot
  sleep 5

  #backup the JBL Token
  cp \$TOKEN .
  #backup cashDB
  [[ \$APS ]] && cp \$CASH . || :

  #remove old backups
  ls | grep -e [JPSApps]_ | xargs rm -fr


  #backup
  mv ./JPSApps ./JPSApps_old
  #Check backup
  if [ \$? != 0 ]
  	then
    rm -rf _update.sh cashDB.fdb AppDB.fdb JPSApps.tar.gz ConfigData_merged.json 2>/dev/null 1>&2
  	echo 'REMOTE: Application folder has not been saved, aborting update. Please contact HUB Support!'
  	exit 1
  fi

  #untar the new package
  tar -xf JPSApps.tar.gz &>/dev/null

  chmod +x -R JPSApps

  #restore data from prevous version

  mv ./ConfigData_merged.json \$JSDIR/ConfigData.json
  if [ \$? != 0 ]
  	then
    echo 'REMOTE CRITICAL ERROR!! \
  	ConfigData.json has not been restored. Please contact HUB Support!'
    rollback
  	exit 3
  fi
  mv ./ConfigData_SCHED_merged.json \${WORKDIR}/JPSApps/JPSApplication/Resources/www/webcfgtool/outsched/ConfigData.json
  if [ \$? != 0 ]
  	then
    echo 'REMOTE CRITICAL ERROR!! \
  	ConfigData.json for scheduler has not been restored. Please contact HUB Support!'
    rollback
  	exit 3
  fi

  mv ./AppDB.fdb \$TOKEN
  if [ \$? != 0 ]
  	then
  	echo 'REMOTE CRITICAL ERROR!! \
  	JBL Token has not been restored. Please contact HUB Support!'
    rollback
  	exit 3
  fi

  if [[ \$APS ]]
    then
    mkdir \$CASHDIR
    mv ./cashDB.fdb \$CASH
  fi
  if [ \$? != 0 ]
  	then
  	echo 'REMOTE CRITICAL ERROR!! \
  	Cash DB has not been restored. Please contact HUB Support!'
    rollback
  	exit 3
  fi
  #clean
  rm -rf _update.sh JPSApps.tar.gz
  sync
  echo "Rebooting"
  reboot
EOF
}
